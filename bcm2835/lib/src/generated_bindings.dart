// ignore_for_file: non_constant_identifier_names, constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// BCM2835 Library
class Bcm2835 {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  Bcm2835(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  Bcm2835.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// ! Physical address and size of the peripherals block
  /// May be overridden on RPi2
  late final ffi.Pointer<MemoryOffset> _bcm2835_peripherals_base =
      _lookup<MemoryOffset>('bcm2835_peripherals_base');

  int get bcm2835_peripherals_base => _bcm2835_peripherals_base.value;

  set bcm2835_peripherals_base(int value) =>
      _bcm2835_peripherals_base.value = value;

  /// ! Size of the peripherals block to be mapped
  late final ffi.Pointer<ffi.Size> _bcm2835_peripherals_size =
      _lookup<ffi.Size>('bcm2835_peripherals_size');

  int get bcm2835_peripherals_size => _bcm2835_peripherals_size.value;

  set bcm2835_peripherals_size(int value) =>
      _bcm2835_peripherals_size.value = value;

  /// ! Virtual memory address of the mapped peripherals block
  late final ffi.Pointer<ffi.Pointer<ffi.Uint32>> _bcm2835_peripherals =
      _lookup<ffi.Pointer<ffi.Uint32>>('bcm2835_peripherals');

  ffi.Pointer<ffi.Uint32> get bcm2835_peripherals => _bcm2835_peripherals.value;

  set bcm2835_peripherals(ffi.Pointer<ffi.Uint32> value) =>
      _bcm2835_peripherals.value = value;

  /// ! Base of the ST (System Timer) registers.
  /// Available after bcm2835_init has been called (as root)
  late final ffi.Pointer<ffi.Pointer<ffi.Uint32>> _bcm2835_st =
      _lookup<ffi.Pointer<ffi.Uint32>>('bcm2835_st');

  ffi.Pointer<ffi.Uint32> get bcm2835_st => _bcm2835_st.value;

  set bcm2835_st(ffi.Pointer<ffi.Uint32> value) => _bcm2835_st.value = value;

  /// ! Base of the GPIO registers.
  /// Available after bcm2835_init has been called
  late final ffi.Pointer<ffi.Pointer<ffi.Uint32>> _bcm2835_gpio =
      _lookup<ffi.Pointer<ffi.Uint32>>('bcm2835_gpio');

  ffi.Pointer<ffi.Uint32> get bcm2835_gpio => _bcm2835_gpio.value;

  set bcm2835_gpio(ffi.Pointer<ffi.Uint32> value) =>
      _bcm2835_gpio.value = value;

  /// ! Base of the PWM registers.
  /// Available after bcm2835_init has been called (as root)
  late final ffi.Pointer<ffi.Pointer<ffi.Uint32>> _bcm2835_pwm =
      _lookup<ffi.Pointer<ffi.Uint32>>('bcm2835_pwm');

  ffi.Pointer<ffi.Uint32> get bcm2835_pwm => _bcm2835_pwm.value;

  set bcm2835_pwm(ffi.Pointer<ffi.Uint32> value) => _bcm2835_pwm.value = value;

  /// ! Base of the CLK registers.
  /// Available after bcm2835_init has been called (as root)
  late final ffi.Pointer<ffi.Pointer<ffi.Uint32>> _bcm2835_clk =
      _lookup<ffi.Pointer<ffi.Uint32>>('bcm2835_clk');

  ffi.Pointer<ffi.Uint32> get bcm2835_clk => _bcm2835_clk.value;

  set bcm2835_clk(ffi.Pointer<ffi.Uint32> value) => _bcm2835_clk.value = value;

  /// ! Base of the PADS registers.
  /// Available after bcm2835_init has been called (as root)
  late final ffi.Pointer<ffi.Pointer<ffi.Uint32>> _bcm2835_pads =
      _lookup<ffi.Pointer<ffi.Uint32>>('bcm2835_pads');

  ffi.Pointer<ffi.Uint32> get bcm2835_pads => _bcm2835_pads.value;

  set bcm2835_pads(ffi.Pointer<ffi.Uint32> value) =>
      _bcm2835_pads.value = value;

  /// ! Base of the SPI0 registers.
  /// Available after bcm2835_init has been called (as root)
  late final ffi.Pointer<ffi.Pointer<ffi.Uint32>> _bcm2835_spi0 =
      _lookup<ffi.Pointer<ffi.Uint32>>('bcm2835_spi0');

  ffi.Pointer<ffi.Uint32> get bcm2835_spi0 => _bcm2835_spi0.value;

  set bcm2835_spi0(ffi.Pointer<ffi.Uint32> value) =>
      _bcm2835_spi0.value = value;

  /// ! Base of the BSC0 registers.
  /// Available after bcm2835_init has been called (as root)
  late final ffi.Pointer<ffi.Pointer<ffi.Uint32>> _bcm2835_bsc0 =
      _lookup<ffi.Pointer<ffi.Uint32>>('bcm2835_bsc0');

  ffi.Pointer<ffi.Uint32> get bcm2835_bsc0 => _bcm2835_bsc0.value;

  set bcm2835_bsc0(ffi.Pointer<ffi.Uint32> value) =>
      _bcm2835_bsc0.value = value;

  /// ! Base of the BSC1 registers.
  /// Available after bcm2835_init has been called (as root)
  late final ffi.Pointer<ffi.Pointer<ffi.Uint32>> _bcm2835_bsc1 =
      _lookup<ffi.Pointer<ffi.Uint32>>('bcm2835_bsc1');

  ffi.Pointer<ffi.Uint32> get bcm2835_bsc1 => _bcm2835_bsc1.value;

  set bcm2835_bsc1(ffi.Pointer<ffi.Uint32> value) =>
      _bcm2835_bsc1.value = value;

  /// ! Base of the AUX registers.
  /// Available after bcm2835_init has been called (as root)
  late final ffi.Pointer<ffi.Pointer<ffi.Uint32>> _bcm2835_aux =
      _lookup<ffi.Pointer<ffi.Uint32>>('bcm2835_aux');

  ffi.Pointer<ffi.Uint32> get bcm2835_aux => _bcm2835_aux.value;

  set bcm2835_aux(ffi.Pointer<ffi.Uint32> value) => _bcm2835_aux.value = value;

  /// ! Base of the SPI1 registers.
  /// Available after bcm2835_init has been called (as root)
  late final ffi.Pointer<ffi.Pointer<ffi.Uint32>> _bcm2835_spi1 =
      _lookup<ffi.Pointer<ffi.Uint32>>('bcm2835_spi1');

  ffi.Pointer<ffi.Uint32> get bcm2835_spi1 => _bcm2835_spi1.value;

  set bcm2835_spi1(ffi.Pointer<ffi.Uint32> value) =>
      _bcm2835_spi1.value = value;

  /// ! Base of SMI registers.
  /// Available after bcm2835_init has been called (as root)
  late final ffi.Pointer<ffi.Pointer<ffi.Uint32>> _bcm2835_smi =
      _lookup<ffi.Pointer<ffi.Uint32>>('bcm2835_smi');

  ffi.Pointer<ffi.Uint32> get bcm2835_smi => _bcm2835_smi.value;

  set bcm2835_smi(ffi.Pointer<ffi.Uint32> value) => _bcm2835_smi.value = value;

  /// ! Initialise the library by opening /dev/mem (if you are root)
  /// or /dev/gpiomem (if you are not)
  /// and getting pointers to the
  /// internal memory for BCM 2835 device registers. You must call this (successfully)
  /// before calling any other
  /// functions in this library (except bcm2835_set_debug).
  /// If bcm2835_init() fails by returning 0,
  /// calling any other function may result in crashes or other failures.
  /// If bcm2835_init() succeeds but you are not running as root, then only gpio operations
  /// are permitted, and calling any other functions may result in crashes or other failures. .
  /// Prints messages to stderr in case of errors.
  /// \return 1 if successful else 0
  int init() {
    return _init();
  }

  late final _initPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('bcm2835_init');
  late final _init = _initPtr.asFunction<int Function()>();

  /// ! Close the library, deallocating any allocated memory and closing /dev/mem
  /// \return 1 if successful else 0
  int close() {
    return _close();
  }

  late final _closePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('bcm2835_close');
  late final _close = _closePtr.asFunction<int Function()>();

  /// ! Sets the debug level of the library.
  /// A value of 1 prevents mapping to /dev/mem, and makes the library print out
  /// what it would do, rather than accessing the GPIO registers.
  /// A value of 0, the default, causes normal operation.
  /// Call this before calling bcm2835_init();
  /// \param[in] debug The new debug level. 1 means debug
  void set_debug(
    int debug,
  ) {
    return _set_debug(
      debug,
    );
  }

  late final _set_debugPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint8)>>(
          'bcm2835_set_debug');
  late final _set_debug = _set_debugPtr.asFunction<void Function(int)>();

  /// ! Returns the version number of the library, same as BCM2835_VERSION
  /// \return the current library version number
  int version() {
    return _version();
  }

  late final _versionPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function()>>(
          'bcm2835_version');
  late final _version = _versionPtr.asFunction<int Function()>();

  /// ! Gets the base of a register
  /// \param[in] regbase You can use one of the common values BCM2835_REGBASE_*
  /// in \ref bcm2835RegisterBase
  /// \return the register base
  /// \sa Physical Addresses
  ffi.Pointer<ffi.Uint32> regbase(
    int regbase,
  ) {
    return _regbase(
      regbase,
    );
  }

  late final _regbasePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Uint32> Function(ffi.Uint8)>>(
          'bcm2835_regbase');
  late final _regbase =
      _regbasePtr.asFunction<ffi.Pointer<ffi.Uint32> Function(int)>();

  /// ! Reads 32 bit value from a peripheral address WITH a memory barrier before and after each read.
  /// This is safe, but slow.  The MB before protects this read from any in-flight reads that didn't
  /// use a MB.  The MB after protects subsequent reads from another peripheral.
  ///
  /// \param[in] paddr Physical address to read from. See BCM2835_GPIO_BASE etc.
  /// \return the value read from the 32 bit register
  /// \sa Physical Addresses
  int peri_read(
    ffi.Pointer<ffi.Uint32> paddr,
  ) {
    return _peri_read(
      paddr,
    );
  }

  late final _peri_readPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<ffi.Uint32>)>>(
          'bcm2835_peri_read');
  late final _peri_read =
      _peri_readPtr.asFunction<int Function(ffi.Pointer<ffi.Uint32>)>();

  /// ! Reads 32 bit value from a peripheral address WITHOUT the read barriers
  /// You should only use this when:
  /// o your code has previously called bcm2835_peri_read() for a register
  /// within the same peripheral, and no read or write to another peripheral has occurred since.
  /// o your code has called bcm2835_memory_barrier() since the last access to ANOTHER peripheral.
  ///
  /// \param[in] paddr Physical address to read from. See BCM2835_GPIO_BASE etc.
  /// \return the value read from the 32 bit register
  /// \sa Physical Addresses
  int peri_read_nb(
    ffi.Pointer<ffi.Uint32> paddr,
  ) {
    return _peri_read_nb(
      paddr,
    );
  }

  late final _peri_read_nbPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<ffi.Uint32>)>>(
          'bcm2835_peri_read_nb');
  late final _peri_read_nb =
      _peri_read_nbPtr.asFunction<int Function(ffi.Pointer<ffi.Uint32>)>();

  /// ! Writes 32 bit value from a peripheral address WITH a memory barrier before and after each write
  /// This is safe, but slow.  The MB before ensures that any in-flight write to another peripheral
  /// completes before this write is issued.  The MB after ensures that subsequent reads and writes
  /// to another peripheral will see the effect of this write.
  ///
  /// This is a tricky optimization; if you aren't sure, use the barrier version.
  ///
  /// \param[in] paddr Physical address to read from. See BCM2835_GPIO_BASE etc.
  /// \param[in] value The 32 bit value to write
  /// \sa Physical Addresses
  void peri_write(
    ffi.Pointer<ffi.Uint32> paddr,
    int value,
  ) {
    return _peri_write(
      paddr,
      value,
    );
  }

  late final _peri_writePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Uint32>, ffi.Uint32)>>('bcm2835_peri_write');
  late final _peri_write =
      _peri_writePtr.asFunction<void Function(ffi.Pointer<ffi.Uint32>, int)>();

  /// ! Writes 32 bit value from a peripheral address without the write barrier
  /// You should only use this when:
  /// o your code has previously called bcm2835_peri_write() for a register
  /// within the same peripheral, and no other peripheral access has occurred since.
  /// o your code has called bcm2835_memory_barrier() since the last access to ANOTHER peripheral.
  ///
  /// This is a tricky optimization; if you aren't sure, use the barrier version.
  ///
  /// \param[in] paddr Physical address to read from. See BCM2835_GPIO_BASE etc.
  /// \param[in] value The 32 bit value to write
  /// \sa Physical Addresses
  void peri_write_nb(
    ffi.Pointer<ffi.Uint32> paddr,
    int value,
  ) {
    return _peri_write_nb(
      paddr,
      value,
    );
  }

  late final _peri_write_nbPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Uint32>, ffi.Uint32)>>('bcm2835_peri_write_nb');
  late final _peri_write_nb = _peri_write_nbPtr
      .asFunction<void Function(ffi.Pointer<ffi.Uint32>, int)>();

  /// ! Alters a number of bits in a 32 peripheral regsiter.
  /// It reads the current valu and then alters the bits defines as 1 in mask,
  /// according to the bit value in value.
  /// All other bits that are 0 in the mask are unaffected.
  /// Use this to alter a subset of the bits in a register.
  /// Memory barriers are used.  Note that this is not atomic; an interrupt
  /// routine can cause unexpected results.
  /// \param[in] paddr Physical address to read from. See BCM2835_GPIO_BASE etc.
  /// \param[in] value The 32 bit value to write, masked in by mask.
  /// \param[in] mask Bitmask that defines the bits that will be altered in the register.
  /// \sa Physical Addresses
  void peri_set_bits(
    ffi.Pointer<ffi.Uint32> paddr,
    int value,
    int mask,
  ) {
    return _peri_set_bits(
      paddr,
      value,
      mask,
    );
  }

  late final _peri_set_bitsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Uint32>, ffi.Uint32,
              ffi.Uint32)>>('bcm2835_peri_set_bits');
  late final _peri_set_bits = _peri_set_bitsPtr
      .asFunction<void Function(ffi.Pointer<ffi.Uint32>, int, int)>();

  /// ! Sets the Function Select register for the given pin, which configures
  /// the pin as Input, Output or one of the 6 alternate functions.
  /// \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
  /// \param[in] mode Mode to set the pin to, one of BCM2835_GPIO_FSEL_* from \ref bcm2835FunctionSelect
  void gpio_fsel(
    int pin,
    int mode,
  ) {
    return _gpio_fsel(
      pin,
      mode,
    );
  }

  late final _gpio_fselPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint8, ffi.Uint8)>>(
          'bcm2835_gpio_fsel');
  late final _gpio_fsel = _gpio_fselPtr.asFunction<void Function(int, int)>();

  /// ! Sets the specified pin output to
  /// HIGH.
  /// \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
  /// \sa bcm2835_gpio_write()
  void gpio_set(
    int pin,
  ) {
    return _gpio_set(
      pin,
    );
  }

  late final _gpio_setPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint8)>>(
          'bcm2835_gpio_set');
  late final _gpio_set = _gpio_setPtr.asFunction<void Function(int)>();

  /// ! Sets the specified pin output to
  /// LOW.
  /// \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
  /// \sa bcm2835_gpio_write()
  void gpio_clr(
    int pin,
  ) {
    return _gpio_clr(
      pin,
    );
  }

  late final _gpio_clrPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint8)>>(
          'bcm2835_gpio_clr');
  late final _gpio_clr = _gpio_clrPtr.asFunction<void Function(int)>();

  /// ! Sets any of the first 32 GPIO output pins specified in the mask to
  /// HIGH.
  /// \param[in] mask Mask of pins to affect. Use eg: (1 << RPI_GPIO_P1_03) | (1 << RPI_GPIO_P1_05)
  /// \sa bcm2835_gpio_write_multi()
  void gpio_set_multi(
    int mask,
  ) {
    return _gpio_set_multi(
      mask,
    );
  }

  late final _gpio_set_multiPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint32)>>(
          'bcm2835_gpio_set_multi');
  late final _gpio_set_multi =
      _gpio_set_multiPtr.asFunction<void Function(int)>();

  /// ! Sets any of the first 32 GPIO output pins specified in the mask to
  /// LOW.
  /// \param[in] mask Mask of pins to affect. Use eg: (1 << RPI_GPIO_P1_03) | (1 << RPI_GPIO_P1_05)
  /// \sa bcm2835_gpio_write_multi()
  void gpio_clr_multi(
    int mask,
  ) {
    return _gpio_clr_multi(
      mask,
    );
  }

  late final _gpio_clr_multiPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint32)>>(
          'bcm2835_gpio_clr_multi');
  late final _gpio_clr_multi =
      _gpio_clr_multiPtr.asFunction<void Function(int)>();

  /// ! Reads the current level on the specified
  /// pin and returns either HIGH or LOW. Works whether or not the pin
  /// is an input or an output.
  /// \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
  /// \return the current level  either HIGH or LOW
  int gpio_lev(
    int pin,
  ) {
    return _gpio_lev(
      pin,
    );
  }

  late final _gpio_levPtr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Uint8)>>(
          'bcm2835_gpio_lev');
  late final _gpio_lev = _gpio_levPtr.asFunction<int Function(int)>();

  /// ! Event Detect Status.
  /// Tests whether the specified pin has detected a level or edge
  /// as requested by bcm2835_gpio_ren(), bcm2835_gpio_fen(), bcm2835_gpio_hen(),
  /// bcm2835_gpio_len(), bcm2835_gpio_aren(), bcm2835_gpio_afen().
  /// Clear the flag for a given pin by calling bcm2835_gpio_set_eds(pin);
  /// \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
  /// \return HIGH if the event detect status for the given pin is true.
  int gpio_eds(
    int pin,
  ) {
    return _gpio_eds(
      pin,
    );
  }

  late final _gpio_edsPtr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Uint8)>>(
          'bcm2835_gpio_eds');
  late final _gpio_eds = _gpio_edsPtr.asFunction<int Function(int)>();

  /// ! Same as bcm2835_gpio_eds() but checks if any of the pins specified in
  /// the mask have detected a level or edge.
  /// \param[in] mask Mask of pins to check. Use eg: (1 << RPI_GPIO_P1_03) | (1 << RPI_GPIO_P1_05)
  /// \return Mask of pins HIGH if the event detect status for the given pin is true.
  int gpio_eds_multi(
    int mask,
  ) {
    return _gpio_eds_multi(
      mask,
    );
  }

  late final _gpio_eds_multiPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Uint32)>>(
          'bcm2835_gpio_eds_multi');
  late final _gpio_eds_multi =
      _gpio_eds_multiPtr.asFunction<int Function(int)>();

  /// ! Sets the Event Detect Status register for a given pin to 1,
  /// which has the effect of clearing the flag. Use this afer seeing
  /// an Event Detect Status on the pin.
  /// \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
  void gpio_set_eds(
    int pin,
  ) {
    return _gpio_set_eds(
      pin,
    );
  }

  late final _gpio_set_edsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint8)>>(
          'bcm2835_gpio_set_eds');
  late final _gpio_set_eds = _gpio_set_edsPtr.asFunction<void Function(int)>();

  /// ! Same as bcm2835_gpio_set_eds() but clears the flag for any pin which
  /// is set in the mask.
  /// \param[in] mask Mask of pins to clear. Use eg: (1 << RPI_GPIO_P1_03) | (1 << RPI_GPIO_P1_05)
  void gpio_set_eds_multi(
    int mask,
  ) {
    return _gpio_set_eds_multi(
      mask,
    );
  }

  late final _gpio_set_eds_multiPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint32)>>(
          'bcm2835_gpio_set_eds_multi');
  late final _gpio_set_eds_multi =
      _gpio_set_eds_multiPtr.asFunction<void Function(int)>();

  /// ! Enable Rising Edge Detect Enable for the specified pin.
  /// When a rising edge is detected, sets the appropriate pin in Event Detect Status.
  /// The GPRENn registers use
  /// synchronous edge detection. This means the input signal is sampled using the
  /// system clock and then it is looking for a ?011? pattern on the sampled signal. This
  /// has the effect of suppressing glitches.
  /// \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
  void gpio_ren(
    int pin,
  ) {
    return _gpio_ren(
      pin,
    );
  }

  late final _gpio_renPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint8)>>(
          'bcm2835_gpio_ren');
  late final _gpio_ren = _gpio_renPtr.asFunction<void Function(int)>();

  /// ! Disable Rising Edge Detect Enable for the specified pin.
  /// \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
  void gpio_clr_ren(
    int pin,
  ) {
    return _gpio_clr_ren(
      pin,
    );
  }

  late final _gpio_clr_renPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint8)>>(
          'bcm2835_gpio_clr_ren');
  late final _gpio_clr_ren = _gpio_clr_renPtr.asFunction<void Function(int)>();

  /// ! Enable Falling Edge Detect Enable for the specified pin.
  /// When a falling edge is detected, sets the appropriate pin in Event Detect Status.
  /// The GPRENn registers use
  /// synchronous edge detection. This means the input signal is sampled using the
  /// system clock and then it is looking for a ?100? pattern on the sampled signal. This
  /// has the effect of suppressing glitches.
  /// \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
  void gpio_fen(
    int pin,
  ) {
    return _gpio_fen(
      pin,
    );
  }

  late final _gpio_fenPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint8)>>(
          'bcm2835_gpio_fen');
  late final _gpio_fen = _gpio_fenPtr.asFunction<void Function(int)>();

  /// ! Disable Falling Edge Detect Enable for the specified pin.
  /// \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
  void gpio_clr_fen(
    int pin,
  ) {
    return _gpio_clr_fen(
      pin,
    );
  }

  late final _gpio_clr_fenPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint8)>>(
          'bcm2835_gpio_clr_fen');
  late final _gpio_clr_fen = _gpio_clr_fenPtr.asFunction<void Function(int)>();

  /// ! Enable High Detect Enable for the specified pin.
  /// When a HIGH level is detected on the pin, sets the appropriate pin in Event Detect Status.
  /// \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
  void gpio_hen(
    int pin,
  ) {
    return _gpio_hen(
      pin,
    );
  }

  late final _gpio_henPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint8)>>(
          'bcm2835_gpio_hen');
  late final _gpio_hen = _gpio_henPtr.asFunction<void Function(int)>();

  /// ! Disable High Detect Enable for the specified pin.
  /// \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
  void gpio_clr_hen(
    int pin,
  ) {
    return _gpio_clr_hen(
      pin,
    );
  }

  late final _gpio_clr_henPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint8)>>(
          'bcm2835_gpio_clr_hen');
  late final _gpio_clr_hen = _gpio_clr_henPtr.asFunction<void Function(int)>();

  /// ! Enable Low Detect Enable for the specified pin.
  /// When a LOW level is detected on the pin, sets the appropriate pin in Event Detect Status.
  /// \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
  void gpio_len(
    int pin,
  ) {
    return _gpio_len(
      pin,
    );
  }

  late final _gpio_lenPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint8)>>(
          'bcm2835_gpio_len');
  late final _gpio_len = _gpio_lenPtr.asFunction<void Function(int)>();

  /// ! Disable Low Detect Enable for the specified pin.
  /// \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
  void gpio_clr_len(
    int pin,
  ) {
    return _gpio_clr_len(
      pin,
    );
  }

  late final _gpio_clr_lenPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint8)>>(
          'bcm2835_gpio_clr_len');
  late final _gpio_clr_len = _gpio_clr_lenPtr.asFunction<void Function(int)>();

  /// ! Enable Asynchronous Rising Edge Detect Enable for the specified pin.
  /// When a rising edge is detected, sets the appropriate pin in Event Detect Status.
  /// Asynchronous means the incoming signal is not sampled by the system clock. As such
  /// rising edges of very short duration can be detected.
  /// \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
  void gpio_aren(
    int pin,
  ) {
    return _gpio_aren(
      pin,
    );
  }

  late final _gpio_arenPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint8)>>(
          'bcm2835_gpio_aren');
  late final _gpio_aren = _gpio_arenPtr.asFunction<void Function(int)>();

  /// ! Disable Asynchronous Rising Edge Detect Enable for the specified pin.
  /// \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
  void gpio_clr_aren(
    int pin,
  ) {
    return _gpio_clr_aren(
      pin,
    );
  }

  late final _gpio_clr_arenPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint8)>>(
          'bcm2835_gpio_clr_aren');
  late final _gpio_clr_aren =
      _gpio_clr_arenPtr.asFunction<void Function(int)>();

  /// ! Enable Asynchronous Falling Edge Detect Enable for the specified pin.
  /// When a falling edge is detected, sets the appropriate pin in Event Detect Status.
  /// Asynchronous means the incoming signal is not sampled by the system clock. As such
  /// falling edges of very short duration can be detected.
  /// \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
  void gpio_afen(
    int pin,
  ) {
    return _gpio_afen(
      pin,
    );
  }

  late final _gpio_afenPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint8)>>(
          'bcm2835_gpio_afen');
  late final _gpio_afen = _gpio_afenPtr.asFunction<void Function(int)>();

  /// ! Disable Asynchronous Falling Edge Detect Enable for the specified pin.
  /// \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
  void gpio_clr_afen(
    int pin,
  ) {
    return _gpio_clr_afen(
      pin,
    );
  }

  late final _gpio_clr_afenPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint8)>>(
          'bcm2835_gpio_clr_afen');
  late final _gpio_clr_afen =
      _gpio_clr_afenPtr.asFunction<void Function(int)>();

  /// ! Sets the Pull-up/down register for the given pin. This is
  /// used with bcm2835_gpio_pudclk() to set the  Pull-up/down resistor for the given pin.
  /// However, it is usually more convenient to use bcm2835_gpio_set_pud().
  /// \param[in] pud The desired Pull-up/down mode. One of BCM2835_GPIO_PUD_* from bcm2835PUDControl
  /// On the RPI 4, although this function and bcm2835_gpio_pudclk() are supported for backward
  /// compatibility, new code should always use bcm2835_gpio_set_pud().
  /// \sa bcm2835_gpio_set_pud()
  void gpio_pud(
    int pud,
  ) {
    return _gpio_pud(
      pud,
    );
  }

  late final _gpio_pudPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint8)>>(
          'bcm2835_gpio_pud');
  late final _gpio_pud = _gpio_pudPtr.asFunction<void Function(int)>();

  /// ! Clocks the Pull-up/down value set earlier by bcm2835_gpio_pud() into the pin.
  /// \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
  /// \param[in] on HIGH to clock the value from bcm2835_gpio_pud() into the pin.
  /// LOW to remove the clock.
  ///
  /// On the RPI 4, although this function and bcm2835_gpio_pud() are supported for backward
  /// compatibility, new code should always use bcm2835_gpio_set_pud().
  ///
  /// \sa bcm2835_gpio_set_pud()
  void gpio_pudclk(
    int pin,
    int on1,
  ) {
    return _gpio_pudclk(
      pin,
      on1,
    );
  }

  late final _gpio_pudclkPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint8, ffi.Uint8)>>(
          'bcm2835_gpio_pudclk');
  late final _gpio_pudclk =
      _gpio_pudclkPtr.asFunction<void Function(int, int)>();

  /// ! Reads and returns the Pad Control for the given GPIO group.
  /// Caution: requires root access.
  /// \param[in] group The GPIO pad group number, one of BCM2835_PAD_GROUP_GPIO_*
  /// \return Mask of bits from BCM2835_PAD_* from \ref bcm2835PadGroup
  int gpio_pad(
    int group,
  ) {
    return _gpio_pad(
      group,
    );
  }

  late final _gpio_padPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Uint8)>>(
          'bcm2835_gpio_pad');
  late final _gpio_pad = _gpio_padPtr.asFunction<int Function(int)>();

  /// ! Sets the Pad Control for the given GPIO group.
  /// Caution: requires root access.
  /// \param[in] group The GPIO pad group number, one of BCM2835_PAD_GROUP_GPIO_*
  /// \param[in] control Mask of bits from BCM2835_PAD_* from \ref bcm2835PadGroup. Note
  /// that it is not necessary to include BCM2835_PAD_PASSWRD in the mask as this
  /// is automatically included.
  void gpio_set_pad(
    int group,
    int control,
  ) {
    return _gpio_set_pad(
      group,
      control,
    );
  }

  late final _gpio_set_padPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint8, ffi.Uint32)>>(
          'bcm2835_gpio_set_pad');
  late final _gpio_set_pad =
      _gpio_set_padPtr.asFunction<void Function(int, int)>();

  /// ! Delays for the specified number of milliseconds.
  /// Uses nanosleep(), and therefore does not use CPU until the time is up.
  /// However, you are at the mercy of nanosleep(). From the manual for nanosleep():
  /// If the interval specified in req is not an exact multiple of the granularity
  /// underlying  clock  (see  time(7)),  then the interval will be
  /// rounded up to the next multiple. Furthermore, after the sleep completes,
  /// there may still be a delay before the CPU becomes free to once
  /// again execute the calling thread.
  /// \param[in] millis Delay in milliseconds
  void delay(
    int millis,
  ) {
    return _delay(
      millis,
    );
  }

  late final _delayPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>(
          'bcm2835_delay');
  late final _delay = _delayPtr.asFunction<void Function(int)>();

  /// ! Delays for the specified number of microseconds.
  /// Uses a combination of nanosleep() and a busy wait loop on the BCM2835 system timers,
  /// However, you are at the mercy of nanosleep(). From the manual for nanosleep():
  /// If the interval specified in req is not an exact multiple of the granularity
  /// underlying  clock  (see  time(7)),  then the interval will be
  /// rounded up to the next multiple. Furthermore, after the sleep completes,
  /// there may still be a delay before the CPU becomes free to once
  /// again execute the calling thread.
  /// For times less than about 450 microseconds, uses a busy wait on the System Timer.
  /// It is reported that a delay of 0 microseconds on RaspberryPi will in fact
  /// result in a delay of about 80 microseconds. Your mileage may vary.
  /// \param[in] micros Delay in microseconds
  void delayMicroseconds(
    int micros,
  ) {
    return _delayMicroseconds(
      micros,
    );
  }

  late final _delayMicrosecondsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint64)>>(
          'bcm2835_delayMicroseconds');
  late final _delayMicroseconds =
      _delayMicrosecondsPtr.asFunction<void Function(int)>();

  /// ! Sets the output state of the specified pin
  /// \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
  /// \param[in] on HIGH sets the output to HIGH and LOW to LOW.
  void gpio_write(
    int pin,
    int on1,
  ) {
    return _gpio_write(
      pin,
      on1,
    );
  }

  late final _gpio_writePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint8, ffi.Uint8)>>(
          'bcm2835_gpio_write');
  late final _gpio_write = _gpio_writePtr.asFunction<void Function(int, int)>();

  /// ! Sets any of the first 32 GPIO output pins specified in the mask to the state given by on
  /// \param[in] mask Mask of pins to affect. Use eg: (1 << RPI_GPIO_P1_03) | (1 << RPI_GPIO_P1_05)
  /// \param[in] on HIGH sets the output to HIGH and LOW to LOW.
  void gpio_write_multi(
    int mask,
    int on1,
  ) {
    return _gpio_write_multi(
      mask,
      on1,
    );
  }

  late final _gpio_write_multiPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint32, ffi.Uint8)>>(
          'bcm2835_gpio_write_multi');
  late final _gpio_write_multi =
      _gpio_write_multiPtr.asFunction<void Function(int, int)>();

  /// ! Sets the first 32 GPIO output pins specified in the mask to the value given by value
  /// \param[in] value values required for each bit masked in by mask, eg: (1 << RPI_GPIO_P1_03) | (1 << RPI_GPIO_P1_05)
  /// \param[in] mask Mask of pins to affect. Use eg: (1 << RPI_GPIO_P1_03) | (1 << RPI_GPIO_P1_05)
  void gpio_write_mask(
    int value,
    int mask,
  ) {
    return _gpio_write_mask(
      value,
      mask,
    );
  }

  late final _gpio_write_maskPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint32, ffi.Uint32)>>(
          'bcm2835_gpio_write_mask');
  late final _gpio_write_mask =
      _gpio_write_maskPtr.asFunction<void Function(int, int)>();

  /// ! Sets the Pull-up/down mode for the specified pin. This is more convenient than
  /// clocking the mode in with bcm2835_gpio_pud() and bcm2835_gpio_pudclk().
  /// \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
  /// \param[in] pud The desired Pull-up/down mode. One of BCM2835_GPIO_PUD_* from bcm2835PUDControl
  void gpio_set_pud(
    int pin,
    int pud,
  ) {
    return _gpio_set_pud(
      pin,
      pud,
    );
  }

  late final _gpio_set_pudPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint8, ffi.Uint8)>>(
          'bcm2835_gpio_set_pud');
  late final _gpio_set_pud =
      _gpio_set_pudPtr.asFunction<void Function(int, int)>();

  /// ! On the BCM2711 based RPI 4, gets the current Pull-up/down mode for the specified pin.
  /// Returns one of BCM2835_GPIO_PUD_* from bcm2835PUDControl.
  /// On earlier RPI versions not based on the BCM2711, returns BCM2835_GPIO_PUD_ERROR
  /// \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
  int gpio_get_pud(
    int pin,
  ) {
    return _gpio_get_pud(
      pin,
    );
  }

  late final _gpio_get_pudPtr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Uint8)>>(
          'bcm2835_gpio_get_pud');
  late final _gpio_get_pud = _gpio_get_pudPtr.asFunction<int Function(int)>();

  /// ! Start SPI operations.
  /// Forces RPi SPI0 pins P1-19 (MOSI), P1-21 (MISO), P1-23 (CLK), P1-24 (CE0) and P1-26 (CE1)
  /// to alternate function ALT0, which enables those pins for SPI interface.
  /// You should call bcm2835_spi_end() when all SPI funcitons are complete to return the pins to
  /// their default functions.
  /// \sa  bcm2835_spi_end()
  /// \return 1 if successful, 0 otherwise (perhaps because you are not running as root)
  int spi_begin() {
    return _spi_begin();
  }

  late final _spi_beginPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('bcm2835_spi_begin');
  late final _spi_begin = _spi_beginPtr.asFunction<int Function()>();

  /// ! End SPI operations.
  /// SPI0 pins P1-19 (MOSI), P1-21 (MISO), P1-23 (CLK), P1-24 (CE0) and P1-26 (CE1)
  /// are returned to their default INPUT behaviour.
  void spi_end() {
    return _spi_end();
  }

  late final _spi_endPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('bcm2835_spi_end');
  late final _spi_end = _spi_endPtr.asFunction<void Function()>();

  /// ! Sets the SPI bit order
  /// Set the bit order to be used for transmit and receive. The bcm2835 SPI0 only supports BCM2835_SPI_BIT_ORDER_MSB,
  /// so if you select BCM2835_SPI_BIT_ORDER_LSB, the bytes will be reversed in software.
  /// The library defaults to BCM2835_SPI_BIT_ORDER_MSB.
  /// \param[in] order The desired bit order, one of BCM2835_SPI_BIT_ORDER_*,
  /// see \ref bcm2835SPIBitOrder
  void spi_setBitOrder(
    int order,
  ) {
    return _spi_setBitOrder(
      order,
    );
  }

  late final _spi_setBitOrderPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint8)>>(
          'bcm2835_spi_setBitOrder');
  late final _spi_setBitOrder =
      _spi_setBitOrderPtr.asFunction<void Function(int)>();

  /// ! Sets the SPI clock divider and therefore the
  /// SPI clock speed.
  /// \param[in] divider The desired SPI clock divider, one of BCM2835_SPI_CLOCK_DIVIDER_*,
  /// see \ref bcm2835SPIClockDivider
  void spi_setClockDivider(
    int divider,
  ) {
    return _spi_setClockDivider(
      divider,
    );
  }

  late final _spi_setClockDividerPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint16)>>(
          'bcm2835_spi_setClockDivider');
  late final _spi_setClockDivider =
      _spi_setClockDividerPtr.asFunction<void Function(int)>();

  /// ! Sets the SPI clock divider by converting the speed parameter to
  /// the equivalent SPI clock divider. ( see \sa bcm2835_spi_setClockDivider)
  /// \param[in] speed_hz The desired SPI clock speed in Hz
  void spi_set_speed_hz(
    int speed_hz,
  ) {
    return _spi_set_speed_hz(
      speed_hz,
    );
  }

  late final _spi_set_speed_hzPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint32)>>(
          'bcm2835_spi_set_speed_hz');
  late final _spi_set_speed_hz =
      _spi_set_speed_hzPtr.asFunction<void Function(int)>();

  /// ! Sets the SPI data mode
  /// Sets the clock polariy and phase
  /// \param[in] mode The desired data mode, one of BCM2835_SPI_MODE*,
  /// see \ref bcm2835SPIMode
  void spi_setDataMode(
    int mode,
  ) {
    return _spi_setDataMode(
      mode,
    );
  }

  late final _spi_setDataModePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint8)>>(
          'bcm2835_spi_setDataMode');
  late final _spi_setDataMode =
      _spi_setDataModePtr.asFunction<void Function(int)>();

  /// ! Sets the chip select pin(s)
  /// When an bcm2835_spi_transfer() is made, the selected pin(s) will be asserted during the
  /// transfer.
  /// \param[in] cs Specifies the CS pins(s) that are used to activate the desired slave.
  /// One of BCM2835_SPI_CS*, see \ref bcm2835SPIChipSelect
  void spi_chipSelect(
    int cs,
  ) {
    return _spi_chipSelect(
      cs,
    );
  }

  late final _spi_chipSelectPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint8)>>(
          'bcm2835_spi_chipSelect');
  late final _spi_chipSelect =
      _spi_chipSelectPtr.asFunction<void Function(int)>();

  /// ! Sets the chip select pin polarity for a given pin
  /// When an bcm2835_spi_transfer() occurs, the currently selected chip select pin(s)
  /// will be asserted to the
  /// value given by active. When transfers are not happening, the chip select pin(s)
  /// return to the complement (inactive) value.
  /// \param[in] cs The chip select pin to affect
  /// \param[in] active Whether the chip select pin is to be active HIGH
  void spi_setChipSelectPolarity(
    int cs,
    int active,
  ) {
    return _spi_setChipSelectPolarity(
      cs,
      active,
    );
  }

  late final _spi_setChipSelectPolarityPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint8, ffi.Uint8)>>(
          'bcm2835_spi_setChipSelectPolarity');
  late final _spi_setChipSelectPolarity =
      _spi_setChipSelectPolarityPtr.asFunction<void Function(int, int)>();

  /// ! Transfers one byte to and from the currently selected SPI slave.
  /// Asserts the currently selected CS pins (as previously set by bcm2835_spi_chipSelect)
  /// during the transfer.
  /// Clocks the 8 bit value out on MOSI, and simultaneously clocks in data from MISO.
  /// Returns the read data byte from the slave.
  /// Uses polled transfer as per section 10.6.1 of the BCM 2835 ARM Peripherls manual
  /// \param[in] value The 8 bit data byte to write to MOSI
  /// \return The 8 bit byte simultaneously read from  MISO
  /// \sa bcm2835_spi_transfern()
  int spi_transfer(
    int value,
  ) {
    return _spi_transfer(
      value,
    );
  }

  late final _spi_transferPtr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Uint8)>>(
          'bcm2835_spi_transfer');
  late final _spi_transfer = _spi_transferPtr.asFunction<int Function(int)>();

  /// ! Transfers any number of bytes to and from the currently selected SPI slave.
  /// Asserts the currently selected CS pins (as previously set by bcm2835_spi_chipSelect)
  /// during the transfer.
  /// Clocks the len 8 bit bytes out on MOSI, and simultaneously clocks in data from MISO.
  /// The data read read from the slave is placed into rbuf. rbuf must be at least len bytes long
  /// Uses polled transfer as per section 10.6.1 of the BCM 2835 ARM Peripherls manual
  /// \param[in] tbuf Buffer of bytes to send.
  /// \param[out] rbuf Received bytes will by put in this buffer
  /// \param[in] len Number of bytes in the tbuf buffer, and the number of bytes to send/received
  /// \sa bcm2835_spi_transfer()
  void spi_transfernb(
    ffi.Pointer<ffi.Char> tbuf,
    ffi.Pointer<ffi.Char> rbuf,
    int len,
  ) {
    return _spi_transfernb(
      tbuf,
      rbuf,
      len,
    );
  }

  late final _spi_transfernbPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Uint32)>>('bcm2835_spi_transfernb');
  late final _spi_transfernb = _spi_transfernbPtr.asFunction<
      void Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// ! Transfers any number of bytes to and from the currently selected SPI slave
  /// using bcm2835_spi_transfernb.
  /// The returned data from the slave replaces the transmitted data in the buffer.
  /// \param[in,out] buf Buffer of bytes to send. Received bytes will replace the contents
  /// \param[in] len Number of bytes int eh buffer, and the number of bytes to send/received
  /// \sa bcm2835_spi_transfer()
  void spi_transfern(
    ffi.Pointer<ffi.Char> buf,
    int len,
  ) {
    return _spi_transfern(
      buf,
      len,
    );
  }

  late final _spi_transfernPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Char>, ffi.Uint32)>>('bcm2835_spi_transfern');
  late final _spi_transfern =
      _spi_transfernPtr.asFunction<void Function(ffi.Pointer<ffi.Char>, int)>();

  /// ! Transfers any number of bytes to the currently selected SPI slave.
  /// Asserts the currently selected CS pins (as previously set by bcm2835_spi_chipSelect)
  /// during the transfer.
  /// \param[in] buf Buffer of bytes to send.
  /// \param[in] len Number of bytes in the buf buffer, and the number of bytes to send
  void spi_writenb(
    ffi.Pointer<ffi.Char> buf,
    int len,
  ) {
    return _spi_writenb(
      buf,
      len,
    );
  }

  late final _spi_writenbPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Char>, ffi.Uint32)>>('bcm2835_spi_writenb');
  late final _spi_writenb =
      _spi_writenbPtr.asFunction<void Function(ffi.Pointer<ffi.Char>, int)>();

  /// ! Transfers half-word to the currently selected SPI slave.
  /// Asserts the currently selected CS pins (as previously set by bcm2835_spi_chipSelect)
  /// during the transfer.
  /// Clocks the 8 bit value out on MOSI, and simultaneously clocks in data from MISO.
  /// Uses polled transfer as per section 10.6.1 of the BCM 2835 ARM Peripherls manual
  /// \param[in] data The 8 bit data byte to write to MOSI
  /// \sa bcm2835_spi_writenb()
  void spi_write(
    int data,
  ) {
    return _spi_write(
      data,
    );
  }

  late final _spi_writePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint16)>>(
          'bcm2835_spi_write');
  late final _spi_write = _spi_writePtr.asFunction<void Function(int)>();

  /// ! Start AUX SPI operations.
  /// Forces RPi AUX SPI pins P1-38 (MOSI), P1-38 (MISO), P1-40 (CLK) and P1-36 (CE2)
  /// to alternate function ALT4, which enables those pins for SPI interface.
  /// \return 1 if successful, 0 otherwise (perhaps because you are not running as root)
  int aux_spi_begin() {
    return _aux_spi_begin();
  }

  late final _aux_spi_beginPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('bcm2835_aux_spi_begin');
  late final _aux_spi_begin = _aux_spi_beginPtr.asFunction<int Function()>();

  /// ! End AUX SPI operations.
  /// SPI1 pins P1-38 (MOSI), P1-38 (MISO), P1-40 (CLK) and P1-36 (CE2)
  /// are returned to their default INPUT behaviour.
  void aux_spi_end() {
    return _aux_spi_end();
  }

  late final _aux_spi_endPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('bcm2835_aux_spi_end');
  late final _aux_spi_end = _aux_spi_endPtr.asFunction<void Function()>();

  /// ! Sets the AUX SPI clock divider and therefore the AUX SPI clock speed.
  /// \param[in] divider The desired AUX SPI clock divider.
  void aux_spi_setClockDivider(
    int divider,
  ) {
    return _aux_spi_setClockDivider(
      divider,
    );
  }

  late final _aux_spi_setClockDividerPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint16)>>(
          'bcm2835_aux_spi_setClockDivider');
  late final _aux_spi_setClockDivider =
      _aux_spi_setClockDividerPtr.asFunction<void Function(int)>();

  /// !
  /// Calculates the input for \sa bcm2835_aux_spi_setClockDivider
  /// @param speed_hz A value between \sa BCM2835_AUX_SPI_CLOCK_MIN and \sa BCM2835_AUX_SPI_CLOCK_MAX
  /// @return Input for \sa bcm2835_aux_spi_setClockDivider
  int aux_spi_CalcClockDivider(
    int speed_hz,
  ) {
    return _aux_spi_CalcClockDivider(
      speed_hz,
    );
  }

  late final _aux_spi_CalcClockDividerPtr =
      _lookup<ffi.NativeFunction<ffi.Uint16 Function(ffi.Uint32)>>(
          'bcm2835_aux_spi_CalcClockDivider');
  late final _aux_spi_CalcClockDivider =
      _aux_spi_CalcClockDividerPtr.asFunction<int Function(int)>();

  /// ! Transfers half-word to the AUX SPI slave.
  /// Asserts the currently selected CS pins during the transfer.
  /// \param[in] data The 8 bit data byte to write to MOSI
  /// \return The 16 bit byte simultaneously read from  MISO
  /// \sa bcm2835_spi_transfern()
  void aux_spi_write(
    int data,
  ) {
    return _aux_spi_write(
      data,
    );
  }

  late final _aux_spi_writePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint16)>>(
          'bcm2835_aux_spi_write');
  late final _aux_spi_write =
      _aux_spi_writePtr.asFunction<void Function(int)>();

  /// ! Transfers any number of bytes to the AUX SPI slave.
  /// Asserts the CE2 pin during the transfer.
  /// \param[in] buf Buffer of bytes to send.
  /// \param[in] len Number of bytes in the tbuf buffer, and the number of bytes to send
  void aux_spi_writenb(
    ffi.Pointer<ffi.Char> buf,
    int len,
  ) {
    return _aux_spi_writenb(
      buf,
      len,
    );
  }

  late final _aux_spi_writenbPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Char>, ffi.Uint32)>>('bcm2835_aux_spi_writenb');
  late final _aux_spi_writenb = _aux_spi_writenbPtr
      .asFunction<void Function(ffi.Pointer<ffi.Char>, int)>();

  /// ! Transfers any number of bytes to and from the AUX SPI slave
  /// using bcm2835_aux_spi_transfernb.
  /// The returned data from the slave replaces the transmitted data in the buffer.
  /// \param[in,out] buf Buffer of bytes to send. Received bytes will replace the contents
  /// \param[in] len Number of bytes in the buffer, and the number of bytes to send/received
  /// \sa bcm2835_aux_spi_transfer()
  void aux_spi_transfern(
    ffi.Pointer<ffi.Char> buf,
    int len,
  ) {
    return _aux_spi_transfern(
      buf,
      len,
    );
  }

  late final _aux_spi_transfernPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Char>, ffi.Uint32)>>('bcm2835_aux_spi_transfern');
  late final _aux_spi_transfern = _aux_spi_transfernPtr
      .asFunction<void Function(ffi.Pointer<ffi.Char>, int)>();

  /// ! Transfers any number of bytes to and from the AUX SPI slave.
  /// Asserts the CE2 pin during the transfer.
  /// Clocks the len 8 bit bytes out on MOSI, and simultaneously clocks in data from MISO.
  /// The data read read from the slave is placed into rbuf. rbuf must be at least len bytes long
  /// \param[in] tbuf Buffer of bytes to send.
  /// \param[out] rbuf Received bytes will by put in this buffer
  /// \param[in] len Number of bytes in the tbuf buffer, and the number of bytes to send/received
  void aux_spi_transfernb(
    ffi.Pointer<ffi.Char> tbuf,
    ffi.Pointer<ffi.Char> rbuf,
    int len,
  ) {
    return _aux_spi_transfernb(
      tbuf,
      rbuf,
      len,
    );
  }

  late final _aux_spi_transfernbPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Uint32)>>('bcm2835_aux_spi_transfernb');
  late final _aux_spi_transfernb = _aux_spi_transfernbPtr.asFunction<
      void Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// ! Transfers one byte to and from the AUX SPI slave.
  /// Clocks the 8 bit value out on MOSI, and simultaneously clocks in data from MISO.
  /// Returns the read data byte from the slave.
  /// \param[in] value The 8 bit data byte to write to MOSI
  /// \return The 8 bit byte simultaneously read from MISO
  /// \sa bcm2835_aux_spi_transfern()
  int aux_spi_transfer(
    int value,
  ) {
    return _aux_spi_transfer(
      value,
    );
  }

  late final _aux_spi_transferPtr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Uint8)>>(
          'bcm2835_aux_spi_transfer');
  late final _aux_spi_transfer =
      _aux_spi_transferPtr.asFunction<int Function(int)>();

  /// ! Start I2C operations.
  /// Forces RPi I2C pins P1-03 (SDA) and P1-05 (SCL)
  /// to alternate function ALT0, which enables those pins for I2C interface.
  /// You should call bcm2835_i2c_end() when all I2C functions are complete to return the pins to
  /// their default functions
  /// \return 1 if successful, 0 otherwise (perhaps because you are not running as root)
  /// \sa  bcm2835_i2c_end()
  int i2c_begin() {
    return _i2c_begin();
  }

  late final _i2c_beginPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('bcm2835_i2c_begin');
  late final _i2c_begin = _i2c_beginPtr.asFunction<int Function()>();

  /// ! End I2C operations.
  /// I2C pins P1-03 (SDA) and P1-05 (SCL)
  /// are returned to their default INPUT behaviour.
  void i2c_end() {
    return _i2c_end();
  }

  late final _i2c_endPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('bcm2835_i2c_end');
  late final _i2c_end = _i2c_endPtr.asFunction<void Function()>();

  /// ! Sets the I2C slave address.
  /// \param[in] addr The I2C slave address.
  void i2c_setSlaveAddress(
    int addr,
  ) {
    return _i2c_setSlaveAddress(
      addr,
    );
  }

  late final _i2c_setSlaveAddressPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint8)>>(
          'bcm2835_i2c_setSlaveAddress');
  late final _i2c_setSlaveAddress =
      _i2c_setSlaveAddressPtr.asFunction<void Function(int)>();

  /// ! Sets the I2C clock divider and therefore the I2C clock speed.
  /// \param[in] divider The desired I2C clock divider, one of BCM2835_I2C_CLOCK_DIVIDER_*,
  /// see \ref bcm2835I2CClockDivider
  void i2c_setClockDivider(
    int divider,
  ) {
    return _i2c_setClockDivider(
      divider,
    );
  }

  late final _i2c_setClockDividerPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint16)>>(
          'bcm2835_i2c_setClockDivider');
  late final _i2c_setClockDivider =
      _i2c_setClockDividerPtr.asFunction<void Function(int)>();

  /// ! Sets the I2C clock divider by converting the baudrate parameter to
  /// the equivalent I2C clock divider. ( see \sa bcm2835_i2c_setClockDivider)
  /// For the I2C standard 100khz you would set baudrate to 100000
  /// The use of baudrate corresponds to its use in the I2C kernel device
  /// driver. (Of course, bcm2835 has nothing to do with the kernel driver)
  void i2c_set_baudrate(
    int baudrate,
  ) {
    return _i2c_set_baudrate(
      baudrate,
    );
  }

  late final _i2c_set_baudratePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint32)>>(
          'bcm2835_i2c_set_baudrate');
  late final _i2c_set_baudrate =
      _i2c_set_baudratePtr.asFunction<void Function(int)>();

  /// ! Transfers any number of bytes to the currently selected I2C slave.
  /// (as previously set by \sa bcm2835_i2c_setSlaveAddress)
  /// \param[in] buf Buffer of bytes to send.
  /// \param[in] len Number of bytes in the buf buffer, and the number of bytes to send.
  /// \return reason see \ref bcm2835I2CReasonCodes
  int i2c_write(
    ffi.Pointer<ffi.Char> buf,
    int len,
  ) {
    return _i2c_write(
      buf,
      len,
    );
  }

  late final _i2c_writePtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(
              ffi.Pointer<ffi.Char>, ffi.Uint32)>>('bcm2835_i2c_write');
  late final _i2c_write =
      _i2c_writePtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  /// ! Transfers any number of bytes from the currently selected I2C slave.
  /// (as previously set by \sa bcm2835_i2c_setSlaveAddress)
  /// \param[in] buf Buffer of bytes to receive.
  /// \param[in] len Number of bytes in the buf buffer, and the number of bytes to received.
  /// \return reason see \ref bcm2835I2CReasonCodes
  int i2c_read(
    ffi.Pointer<ffi.Char> buf,
    int len,
  ) {
    return _i2c_read(
      buf,
      len,
    );
  }

  late final _i2c_readPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(
              ffi.Pointer<ffi.Char>, ffi.Uint32)>>('bcm2835_i2c_read');
  late final _i2c_read =
      _i2c_readPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  /// ! Allows reading from I2C slaves that require a repeated start (without any prior stop)
  /// to read after the required slave register has been set. For example, the popular
  /// MPL3115A2 pressure and temperature sensor. Note that your device must support or
  /// require this mode. If your device does not require this mode then the standard
  /// combined:
  /// \sa bcm2835_i2c_write
  /// \sa bcm2835_i2c_read
  /// are a better choice.
  /// Will read from the slave previously set by \sa bcm2835_i2c_setSlaveAddress
  /// \param[in] regaddr Buffer containing the slave register you wish to read from.
  /// \param[in] buf Buffer of bytes to receive.
  /// \param[in] len Number of bytes in the buf buffer, and the number of bytes to received.
  /// \return reason see \ref bcm2835I2CReasonCodes
  int i2c_read_register_rs(
    ffi.Pointer<ffi.Char> regaddr,
    ffi.Pointer<ffi.Char> buf,
    int len,
  ) {
    return _i2c_read_register_rs(
      regaddr,
      buf,
      len,
    );
  }

  late final _i2c_read_register_rsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Uint32)>>('bcm2835_i2c_read_register_rs');
  late final _i2c_read_register_rs = _i2c_read_register_rsPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// ! Allows sending an arbitrary number of bytes to I2C slaves before issuing a repeated
  /// start (with no prior stop) and reading a response.
  /// Necessary for devices that require such behavior, such as the MLX90620.
  /// Will write to and read from the slave previously set by \sa bcm2835_i2c_setSlaveAddress
  /// \param[in] cmds Buffer containing the bytes to send before the repeated start condition.
  /// \param[in] cmds_len Number of bytes to send from cmds buffer
  /// \param[in] buf Buffer of bytes to receive.
  /// \param[in] buf_len Number of bytes to receive in the buf buffer.
  /// \return reason see \ref bcm2835I2CReasonCodes
  int i2c_write_read_rs(
    ffi.Pointer<ffi.Char> cmds,
    int cmds_len,
    ffi.Pointer<ffi.Char> buf,
    int buf_len,
  ) {
    return _i2c_write_read_rs(
      cmds,
      cmds_len,
      buf,
      buf_len,
    );
  }

  late final _i2c_write_read_rsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(ffi.Pointer<ffi.Char>, ffi.Uint32,
              ffi.Pointer<ffi.Char>, ffi.Uint32)>>('bcm2835_i2c_write_read_rs');
  late final _i2c_write_read_rs = _i2c_write_read_rsPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, int)>();

  /// ! \defgroup smi SMI bus support
  /// Allows access to SMI bus
  /// @{
  /// /
  /// /*! Start SMI operations.
  /// Forces RPi SMI pins P1-19 (MOSI), P1-21 (MISO), P1-23 (CLK), P1-24 (CE0) and P1-26 (CE1)
  /// to alternate function ALT1, which enables those pins for SMI interface.
  /// You should call bcm2835_smi_end() when all SMI functions are complete to return the pins to
  /// their default functions.
  /// Only address bits SA0 to SA3 are available as RPi uses GPIO0 (SA5) and GPIO1 (SA4) for I2C
  /// HAT identification EEPROM access
  /// \sa  bcm2835_smi_end()
  /// \return 1 if successful, 0 otherwise (perhaps because you are not running as root)
  int smi_begin() {
    return _smi_begin();
  }

  late final _smi_beginPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('bcm2835_smi_begin');
  late final _smi_begin = _smi_beginPtr.asFunction<int Function()>();

  /// ! End SMI operations.
  /// SMI pins P1-19 (MOSI), P1-21 (MISO), P1-23 (CLK), P1-24 (CE0) and P1-26 (CE1)
  /// are returned to their default INPUT behaviour.
  void smi_end() {
    return _smi_end();
  }

  late final _smi_endPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('bcm2835_smi_end');
  late final _smi_end = _smi_endPtr.asFunction<void Function()>();

  /// ! Setup SMI bus cycle timing parameters
  /// There are four SMI channels for read operation and four channels for write operation
  /// Cycles are expressed as multiple of 8ns
  /// Note that Pace cycles are not used (no effect on hardware) but they are required for
  /// configuration. It is recommended to set this value to 1 (and not 0) to have the
  /// smallest cycle in case the hardware would recognize it
  /// \param[in] smichannel SMI configuration slot to setup (0 to 3)
  /// \param[in] readchannel Set to 1 to configure the read channel (0 = configure write channel)
  /// \param[in] setupcycles Time between address assertion on bus and OE/WR signal assertion
  /// \param[in] strobecycles Duration of OE/WR signal assertion
  /// \param[in] holdcycles Time after OE/WR deassertion before address is deasserted
  /// \param[in] pacecycles Time before next SMI bus cycle
  void smi_set_timing(
    int smichannel,
    int readchannel,
    int setupcycles,
    int strobecycles,
    int holdcycles,
    int pacecycles,
  ) {
    return _smi_set_timing(
      smichannel,
      readchannel,
      setupcycles,
      strobecycles,
      holdcycles,
      pacecycles,
    );
  }

  late final _smi_set_timingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Uint32, ffi.Uint32, ffi.Uint32, ffi.Uint32,
              ffi.Uint32, ffi.Uint32)>>('bcm2835_smi_set_timing');
  late final _smi_set_timing = _smi_set_timingPtr
      .asFunction<void Function(int, int, int, int, int, int)>();

  /// ! Transfers one byte to SMI bus.
  /// Uses polled transfer as described in BCM 2835 ARM Peripherals manual
  /// \param[in] timingslot SMI configuration slot to use (0 to 3)
  /// \param[in] data The data byte to write
  /// \param[in] address The address to write to
  /// \sa bcm2835_smi_writenb()
  void smi_write(
    int smichannel,
    int data,
    int address,
  ) {
    return _smi_write(
      smichannel,
      data,
      address,
    );
  }

  late final _smi_writePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Uint32, ffi.Uint8, ffi.Uint32)>>('bcm2835_smi_write');
  late final _smi_write =
      _smi_writePtr.asFunction<void Function(int, int, int)>();

  /// ! Reads one byte from SMI bus.
  /// Uses polled transfer as described in BCM 2835 ARM Peripherals manual
  /// \param[in] smichannel SMI configuration slot to use (0 to 3)
  /// \param[in] address The address to read from
  /// \return value read from SMI bus
  /// \sa bcm2835_smi_readnb()
  int smi_read(
    int smichannel,
    int address,
  ) {
    return _smi_read(
      smichannel,
      address,
    );
  }

  late final _smi_readPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Uint32, ffi.Uint32)>>(
          'bcm2835_smi_read');
  late final _smi_read = _smi_readPtr.asFunction<int Function(int, int)>();

  /// ! Read the System Timer Counter register.
  /// \return the value read from the System Timer Counter Lower 32 bits register
  int st_read() {
    return _st_read();
  }

  late final _st_readPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function()>>('bcm2835_st_read');
  late final _st_read = _st_readPtr.asFunction<int Function()>();

  /// ! Delays for the specified number of microseconds with offset.
  /// \param[in] offset_micros Offset in microseconds
  /// \param[in] micros Delay in microseconds
  void st_delay(
    int offset_micros,
    int micros,
  ) {
    return _st_delay(
      offset_micros,
      micros,
    );
  }

  late final _st_delayPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint64, ffi.Uint64)>>(
          'bcm2835_st_delay');
  late final _st_delay = _st_delayPtr.asFunction<void Function(int, int)>();

  /// ! Sets the PWM clock divisor,
  /// to control the basic PWM pulse widths.
  /// \param[in] divisor Divides the basic 19.2MHz PWM clock. You can use one of the common
  /// values BCM2835_PWM_CLOCK_DIVIDER_* in \ref bcm2835PWMClockDivider
  void pwm_set_clock(
    int divisor,
  ) {
    return _pwm_set_clock(
      divisor,
    );
  }

  late final _pwm_set_clockPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint32)>>(
          'bcm2835_pwm_set_clock');
  late final _pwm_set_clock =
      _pwm_set_clockPtr.asFunction<void Function(int)>();

  /// ! Sets the mode of the given PWM channel,
  /// allowing you to control the PWM mode and enable/disable that channel
  /// \param[in] channel The PWM channel. 0 or 1.
  /// \param[in] markspace Set true if you want Mark-Space mode. 0 for Balanced mode.
  /// \param[in] enabled Set true to enable this channel and produce PWM pulses.
  void pwm_set_mode(
    int channel,
    int markspace,
    int enabled,
  ) {
    return _pwm_set_mode(
      channel,
      markspace,
      enabled,
    );
  }

  late final _pwm_set_modePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Uint8, ffi.Uint8, ffi.Uint8)>>('bcm2835_pwm_set_mode');
  late final _pwm_set_mode =
      _pwm_set_modePtr.asFunction<void Function(int, int, int)>();

  /// ! Sets the maximum range of the PWM output.
  /// The data value can vary between 0 and this range to control PWM output
  /// \param[in] channel The PWM channel. 0 or 1.
  /// \param[in] range The maximum value permitted for DATA.
  void pwm_set_range(
    int channel,
    int range,
  ) {
    return _pwm_set_range(
      channel,
      range,
    );
  }

  late final _pwm_set_rangePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint8, ffi.Uint32)>>(
          'bcm2835_pwm_set_range');
  late final _pwm_set_range =
      _pwm_set_rangePtr.asFunction<void Function(int, int)>();

  /// ! Sets the PWM pulse ratio to emit to DATA/RANGE,
  /// where RANGE is set by bcm2835_pwm_set_range().
  /// \param[in] channel The PWM channel. 0 or 1.
  /// \param[in] data Controls the PWM output ratio as a fraction of the range.
  /// Can vary from 0 to RANGE.
  void pwm_set_data(
    int channel,
    int data,
  ) {
    return _pwm_set_data(
      channel,
      data,
    );
  }

  late final _pwm_set_dataPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint8, ffi.Uint32)>>(
          'bcm2835_pwm_set_data');
  late final _pwm_set_data =
      _pwm_set_dataPtr.asFunction<void Function(int, int)>();
}

typedef MemoryOffset = ffi.Long;

/// ! \brief bcm2835RegisterBase
/// Register bases for bcm2835_regbase()
abstract class RegisterBase {
  /// !< Base of the ST (System Timer) registers.
  static const int REGBASE_ST = 1;

  /// !< Base of the GPIO registers.
  static const int REGBASE_GPIO = 2;

  /// !< Base of the PWM registers.
  static const int REGBASE_PWM = 3;

  /// !< Base of the CLK registers.
  static const int REGBASE_CLK = 4;

  /// !< Base of the PADS registers.
  static const int REGBASE_PADS = 5;

  /// !< Base of the SPI0 registers.
  static const int REGBASE_SPI0 = 6;

  /// !< Base of the BSC0 registers.
  static const int REGBASE_BSC0 = 7;

  /// !< Base of the BSC1 registers.
  static const int REGBASE_BSC1 = 8;

  /// !< Base of the AUX registers.
  static const int REGBASE_AUX = 9;

  /// !< Base of the SPI1 registers.
  static const int REGBASE_SPI1 = 10;

  /// !< Base of the SMI registers.
  static const int REGBASE_SMI = 11;
}

/// !   \brief bcm2835PortFunction
/// Port function select modes for bcm2835_gpio_fsel()
abstract class FunctionSelect {
  /// !< Input 0b000
  static const int GPIO_FSEL_INPT = 0;

  /// !< Output 0b001
  static const int GPIO_FSEL_OUTP = 1;

  /// !< Alternate function 0 0b100
  static const int GPIO_FSEL_ALT0 = 4;

  /// !< Alternate function 1 0b101
  static const int GPIO_FSEL_ALT1 = 5;

  /// !< Alternate function 2 0b110,
  static const int GPIO_FSEL_ALT2 = 6;

  /// !< Alternate function 3 0b111
  static const int GPIO_FSEL_ALT3 = 7;

  /// !< Alternate function 4 0b011
  static const int GPIO_FSEL_ALT4 = 3;

  /// !< Alternate function 5 0b010
  static const int GPIO_FSEL_ALT5 = 2;

  /// !< Function select bits mask 0b111
  static const int GPIO_FSEL_MASK = 7;
}

/// ! \brief bcm2835PUDControl
/// Pullup/Pulldown defines for bcm2835_gpio_pud()
abstract class PUDControl {
  /// !< Off ? disable pull-up/down 0b00
  static const int GPIO_PUD_OFF = 0;

  /// !< Enable Pull Down control 0b01
  static const int GPIO_PUD_DOWN = 1;

  /// !< Enable Pull Up control 0b10
  static const int GPIO_PUD_UP = 2;
}

/// ! \brief bcm2835PadGroup
/// Pad group specification for bcm2835_gpio_pad()
abstract class PadGroup {
  /// !< Pad group for GPIO pads 0 to 27
  static const int PAD_GROUP_GPIO_0_27 = 0;

  /// !< Pad group for GPIO pads 28 to 45
  static const int PAD_GROUP_GPIO_28_45 = 1;

  /// !< Pad group for GPIO pads 46 to 53
  static const int PAD_GROUP_GPIO_46_53 = 2;
}

/// ! \brief GPIO Pin Numbers
///
/// Here we define Raspberry Pin GPIO pins on P1 in terms of the underlying BCM GPIO pin numbers.
/// These can be passed as a pin number to any function requiring a pin.
/// Not all pins on the RPi 26 bin IDE plug are connected to GPIO pins
/// and some can adopt an alternate function.
/// RPi version 2 has some slightly different pinouts, and these are values RPI_V2_*.
/// RPi B+ has yet differnet pinouts and these are defined in RPI_BPLUS_*.
/// At bootup, pins 8 and 10 are set to UART0_TXD, UART0_RXD (ie the alt0 function) respectively
/// When SPI0 is in use (ie after bcm2835_spi_begin()), SPI0 pins are dedicated to SPI
/// and cant be controlled independently.
/// If you are using the RPi Compute Module, just use the GPIO number: there is no need to use one of these
/// symbolic names
abstract class RPiGPIOPin {
  /// !< Version 1, Pin P1-03
  static const int RPI_GPIO_P1_03 = 0;

  /// !< Version 1, Pin P1-05
  static const int RPI_GPIO_P1_05 = 1;

  /// !< Version 1, Pin P1-07
  static const int RPI_GPIO_P1_07 = 4;

  /// !< Version 1, Pin P1-08, defaults to alt function 0 UART0_TXD
  static const int RPI_GPIO_P1_08 = 14;

  /// !< Version 1, Pin P1-10, defaults to alt function 0 UART0_RXD
  static const int RPI_GPIO_P1_10 = 15;

  /// !< Version 1, Pin P1-11
  static const int RPI_GPIO_P1_11 = 17;

  /// !< Version 1, Pin P1-12, can be PWM channel 0 in ALT FUN 5
  static const int RPI_GPIO_P1_12 = 18;

  /// !< Version 1, Pin P1-13
  static const int RPI_GPIO_P1_13 = 21;

  /// !< Version 1, Pin P1-15
  static const int RPI_GPIO_P1_15 = 22;

  /// !< Version 1, Pin P1-16
  static const int RPI_GPIO_P1_16 = 23;

  /// !< Version 1, Pin P1-18
  static const int RPI_GPIO_P1_18 = 24;

  /// !< Version 1, Pin P1-19, MOSI when SPI0 in use
  static const int RPI_GPIO_P1_19 = 10;

  /// !< Version 1, Pin P1-21, MISO when SPI0 in use
  static const int RPI_GPIO_P1_21 = 9;

  /// !< Version 1, Pin P1-22
  static const int RPI_GPIO_P1_22 = 25;

  /// !< Version 1, Pin P1-23, CLK when SPI0 in use
  static const int RPI_GPIO_P1_23 = 11;

  /// !< Version 1, Pin P1-24, CE0 when SPI0 in use
  static const int RPI_GPIO_P1_24 = 8;

  /// !< Version 1, Pin P1-26, CE1 when SPI0 in use
  static const int RPI_GPIO_P1_26 = 7;

  /// !< Version 2, Pin P1-03
  static const int RPI_V2_GPIO_P1_03 = 2;

  /// !< Version 2, Pin P1-05
  static const int RPI_V2_GPIO_P1_05 = 3;

  /// !< Version 2, Pin P1-07
  static const int RPI_V2_GPIO_P1_07 = 4;

  /// !< Version 2, Pin P1-08, defaults to alt function 0 UART0_TXD
  static const int RPI_V2_GPIO_P1_08 = 14;

  /// !< Version 2, Pin P1-10, defaults to alt function 0 UART0_RXD
  static const int RPI_V2_GPIO_P1_10 = 15;

  /// !< Version 2, Pin P1-11
  static const int RPI_V2_GPIO_P1_11 = 17;

  /// !< Version 2, Pin P1-12, can be PWM channel 0 in ALT FUN 5
  static const int RPI_V2_GPIO_P1_12 = 18;

  /// !< Version 2, Pin P1-13
  static const int RPI_V2_GPIO_P1_13 = 27;

  /// !< Version 2, Pin P1-15
  static const int RPI_V2_GPIO_P1_15 = 22;

  /// !< Version 2, Pin P1-16
  static const int RPI_V2_GPIO_P1_16 = 23;

  /// !< Version 2, Pin P1-18
  static const int RPI_V2_GPIO_P1_18 = 24;

  /// !< Version 2, Pin P1-19, MOSI when SPI0 in use
  static const int RPI_V2_GPIO_P1_19 = 10;

  /// !< Version 2, Pin P1-21, MISO when SPI0 in use
  static const int RPI_V2_GPIO_P1_21 = 9;

  /// !< Version 2, Pin P1-22
  static const int RPI_V2_GPIO_P1_22 = 25;

  /// !< Version 2, Pin P1-23, CLK when SPI0 in use
  static const int RPI_V2_GPIO_P1_23 = 11;

  /// !< Version 2, Pin P1-24, CE0 when SPI0 in use
  static const int RPI_V2_GPIO_P1_24 = 8;

  /// !< Version 2, Pin P1-26, CE1 when SPI0 in use
  static const int RPI_V2_GPIO_P1_26 = 7;

  /// !< Version 2, Pin P1-29
  static const int RPI_V2_GPIO_P1_29 = 5;

  /// !< Version 2, Pin P1-31
  static const int RPI_V2_GPIO_P1_31 = 6;

  /// !< Version 2, Pin P1-32
  static const int RPI_V2_GPIO_P1_32 = 12;

  /// !< Version 2, Pin P1-33
  static const int RPI_V2_GPIO_P1_33 = 13;

  /// !< Version 2, Pin P1-35, can be PWM channel 1 in ALT FUN 5
  static const int RPI_V2_GPIO_P1_35 = 19;

  /// !< Version 2, Pin P1-36
  static const int RPI_V2_GPIO_P1_36 = 16;

  /// !< Version 2, Pin P1-37
  static const int RPI_V2_GPIO_P1_37 = 26;

  /// !< Version 2, Pin P1-38
  static const int RPI_V2_GPIO_P1_38 = 20;

  /// !< Version 2, Pin P1-40
  static const int RPI_V2_GPIO_P1_40 = 21;

  /// !< Version 2, Pin P5-03
  static const int RPI_V2_GPIO_P5_03 = 28;

  /// !< Version 2, Pin P5-04
  static const int RPI_V2_GPIO_P5_04 = 29;

  /// !< Version 2, Pin P5-05
  static const int RPI_V2_GPIO_P5_05 = 30;

  /// !< Version 2, Pin P5-06
  static const int RPI_V2_GPIO_P5_06 = 31;

  /// !< B+, Pin J8-03
  static const int RPI_BPLUS_GPIO_J8_03 = 2;

  /// !< B+, Pin J8-05
  static const int RPI_BPLUS_GPIO_J8_05 = 3;

  /// !< B+, Pin J8-07
  static const int RPI_BPLUS_GPIO_J8_07 = 4;

  /// !< B+, Pin J8-08, defaults to alt function 0 UART0_TXD
  static const int RPI_BPLUS_GPIO_J8_08 = 14;

  /// !< B+, Pin J8-10, defaults to alt function 0 UART0_RXD
  static const int RPI_BPLUS_GPIO_J8_10 = 15;

  /// !< B+, Pin J8-11
  static const int RPI_BPLUS_GPIO_J8_11 = 17;

  /// !< B+, Pin J8-12, can be PWM channel 0 in ALT FUN 5
  static const int RPI_BPLUS_GPIO_J8_12 = 18;

  /// !< B+, Pin J8-13
  static const int RPI_BPLUS_GPIO_J8_13 = 27;

  /// !< B+, Pin J8-15
  static const int RPI_BPLUS_GPIO_J8_15 = 22;

  /// !< B+, Pin J8-16
  static const int RPI_BPLUS_GPIO_J8_16 = 23;

  /// !< B+, Pin J8-18
  static const int RPI_BPLUS_GPIO_J8_18 = 24;

  /// !< B+, Pin J8-19, MOSI when SPI0 in use
  static const int RPI_BPLUS_GPIO_J8_19 = 10;

  /// !< B+, Pin J8-21, MISO when SPI0 in use
  static const int RPI_BPLUS_GPIO_J8_21 = 9;

  /// !< B+, Pin J8-22
  static const int RPI_BPLUS_GPIO_J8_22 = 25;

  /// !< B+, Pin J8-23, CLK when SPI0 in use
  static const int RPI_BPLUS_GPIO_J8_23 = 11;

  /// !< B+, Pin J8-24, CE0 when SPI0 in use
  static const int RPI_BPLUS_GPIO_J8_24 = 8;

  /// !< B+, Pin J8-26, CE1 when SPI0 in use
  static const int RPI_BPLUS_GPIO_J8_26 = 7;

  /// !< B+, Pin J8-29,
  static const int RPI_BPLUS_GPIO_J8_29 = 5;

  /// !< B+, Pin J8-31,
  static const int RPI_BPLUS_GPIO_J8_31 = 6;

  /// !< B+, Pin J8-32,
  static const int RPI_BPLUS_GPIO_J8_32 = 12;

  /// !< B+, Pin J8-33,
  static const int RPI_BPLUS_GPIO_J8_33 = 13;

  /// !< B+, Pin J8-35, can be PWM channel 1 in ALT FUN 5
  static const int RPI_BPLUS_GPIO_J8_35 = 19;

  /// !< B+, Pin J8-36,
  static const int RPI_BPLUS_GPIO_J8_36 = 16;

  /// !< B+, Pin J8-37,
  static const int RPI_BPLUS_GPIO_J8_37 = 26;

  /// !< B+, Pin J8-38,
  static const int RPI_BPLUS_GPIO_J8_38 = 20;

  /// !< B+, Pin J8-40,
  static const int RPI_BPLUS_GPIO_J8_40 = 21;
}

/// ! \brief bcm2835SPIBitOrder SPI Bit order
/// Specifies the SPI data bit ordering for bcm2835_spi_setBitOrder()
abstract class SPIBitOrder {
  /// !< LSB First
  static const int SPI_BIT_ORDER_LSBFIRST = 0;

  /// !< MSB First
  static const int SPI_BIT_ORDER_MSBFIRST = 1;
}

/// ! \brief SPI Data mode
/// Specify the SPI data mode to be passed to bcm2835_spi_setDataMode()
abstract class SPIMode {
  /// !< CPOL = 0, CPHA = 0
  static const int SPI_MODE0 = 0;

  /// !< CPOL = 0, CPHA = 1
  static const int SPI_MODE1 = 1;

  /// !< CPOL = 1, CPHA = 0
  static const int SPI_MODE2 = 2;

  /// !< CPOL = 1, CPHA = 1
  static const int SPI_MODE3 = 3;
}

/// ! \brief bcm2835SPIChipSelect
/// Specify the SPI chip select pin(s)
abstract class SPIChipSelect {
  /// !< Chip Select 0
  static const int SPI_CS0 = 0;

  /// !< Chip Select 1
  static const int SPI_CS1 = 1;

  /// !< Chip Select 2 (ie pins CS1 and CS2 are asserted)
  static const int SPI_CS2 = 2;

  /// !< No CS, control it yourself
  static const int SPI_CS_NONE = 3;
}

/// ! \brief bcm2835SPIClockDivider
/// Specifies the divider used to generate the SPI clock from the system clock.
/// Figures below give the divider, clock period and clock frequency.
/// Clock divided is based on nominal core clock rate of 250MHz on RPi1 and RPi2, and 400MHz on RPi3.
/// It is reported that (contrary to the documentation) any even divider may used.
/// The frequencies shown for each divider have been confirmed by measurement on RPi1 and RPi2.
/// The system clock frequency on RPi3 is different, so the frequency you get from a given divider will be different.
/// See comments in 'SPI Pins' for information about reliable SPI speeds.
/// Note: it is possible to change the core clock rate of the RPi 3 back to 250MHz, by putting
/// \code
/// core_freq=250
/// \endcode
/// in the config.txt
abstract class SPIClockDivider {
  /// !< 65536 = 3.814697260kHz on Rpi2, 6.1035156kHz on RPI3
  static const int SPI_CLOCK_DIVIDER_65536 = 0;

  /// !< 32768 = 7.629394531kHz on Rpi2, 12.20703125kHz on RPI3
  static const int SPI_CLOCK_DIVIDER_32768 = 32768;

  /// !< 16384 = 15.25878906kHz on Rpi2, 24.4140625kHz on RPI3
  static const int SPI_CLOCK_DIVIDER_16384 = 16384;

  /// !< 8192 = 30.51757813kHz on Rpi2, 48.828125kHz on RPI3
  static const int SPI_CLOCK_DIVIDER_8192 = 8192;

  /// !< 4096 = 61.03515625kHz on Rpi2, 97.65625kHz on RPI3
  static const int SPI_CLOCK_DIVIDER_4096 = 4096;

  /// !< 2048 = 122.0703125kHz on Rpi2, 195.3125kHz on RPI3
  static const int SPI_CLOCK_DIVIDER_2048 = 2048;

  /// !< 1024 = 244.140625kHz on Rpi2, 390.625kHz on RPI3
  static const int SPI_CLOCK_DIVIDER_1024 = 1024;

  /// !< 512 = 488.28125kHz on Rpi2, 781.25kHz on RPI3
  static const int SPI_CLOCK_DIVIDER_512 = 512;

  /// !< 256 = 976.5625kHz on Rpi2, 1.5625MHz on RPI3
  static const int SPI_CLOCK_DIVIDER_256 = 256;

  /// !< 128 = 1.953125MHz on Rpi2, 3.125MHz on RPI3
  static const int SPI_CLOCK_DIVIDER_128 = 128;

  /// !< 64 = 3.90625MHz on Rpi2, 6.250MHz on RPI3
  static const int SPI_CLOCK_DIVIDER_64 = 64;

  /// !< 32 = 7.8125MHz on Rpi2, 12.5MHz on RPI3
  static const int SPI_CLOCK_DIVIDER_32 = 32;

  /// !< 16 = 15.625MHz on Rpi2, 25MHz on RPI3
  static const int SPI_CLOCK_DIVIDER_16 = 16;

  /// !< 8 = 31.25MHz on Rpi2, 50MHz on RPI3
  static const int SPI_CLOCK_DIVIDER_8 = 8;

  /// !< 4 = 62.5MHz on Rpi2, 100MHz on RPI3. Dont expect this speed to work reliably.
  static const int SPI_CLOCK_DIVIDER_4 = 4;

  /// !< 2 = 125MHz on Rpi2, 200MHz on RPI3, fastest you can get. Dont expect this speed to work reliably.
  static const int SPI_CLOCK_DIVIDER_2 = 2;

  /// !< 1 = 3.814697260kHz on Rpi2, 6.1035156kHz on RPI3, same as 0/65536
  static const int SPI_CLOCK_DIVIDER_1 = 1;
}

/// ! \brief bcm2835I2CClockDivider
/// Specifies the divider used to generate the I2C clock from the system clock.
/// Clock divided is based on nominal base clock rate of 250MHz
abstract class I2CClockDivider {
  /// !< 2500 = 10us = 100 kHz
  static const int I2C_CLOCK_DIVIDER_2500 = 2500;

  /// !< 622 = 2.504us = 399.3610 kHz
  static const int I2C_CLOCK_DIVIDER_626 = 626;

  /// !< 150 = 60ns = 1.666 MHz (default at reset)
  static const int I2C_CLOCK_DIVIDER_150 = 150;

  /// !< 148 = 59ns = 1.689 MHz
  static const int I2C_CLOCK_DIVIDER_148 = 148;
}

/// ! \brief bcm2835I2CReasonCodes
/// Specifies the reason codes for the bcm2835_i2c_write and bcm2835_i2c_read functions.
abstract class I2CReasonCodes {
  /// !< Success
  static const int I2C_REASON_OK = 0;

  /// !< Received a NACK
  static const int I2C_REASON_ERROR_NACK = 1;

  /// !< Received Clock Stretch Timeout
  static const int I2C_REASON_ERROR_CLKT = 2;

  /// !< Not all data is sent / received
  static const int I2C_REASON_ERROR_DATA = 4;
}

/// ! \brief bcm2835PWMClockDivider
/// Specifies the divider used to generate the PWM clock from the system clock.
/// Figures below give the divider, clock period and clock frequency.
/// Clock divided is based on nominal PWM base clock rate of 19.2MHz
/// The frequencies shown for each divider have been confirmed by measurement
abstract class PWMClockDivider {
  /// !< 2048 = 9.375kHz
  static const int PWM_CLOCK_DIVIDER_2048 = 2048;

  /// !< 1024 = 18.75kHz
  static const int PWM_CLOCK_DIVIDER_1024 = 1024;

  /// !< 512 = 37.5kHz
  static const int PWM_CLOCK_DIVIDER_512 = 512;

  /// !< 256 = 75kHz
  static const int PWM_CLOCK_DIVIDER_256 = 256;

  /// !< 128 = 150kHz
  static const int PWM_CLOCK_DIVIDER_128 = 128;

  /// !< 64 = 300kHz
  static const int PWM_CLOCK_DIVIDER_64 = 64;

  /// !< 32 = 600.0kHz
  static const int PWM_CLOCK_DIVIDER_32 = 32;

  /// !< 16 = 1.2MHz
  static const int PWM_CLOCK_DIVIDER_16 = 16;

  /// !< 8 = 2.4MHz
  static const int PWM_CLOCK_DIVIDER_8 = 8;

  /// !< 4 = 4.8MHz
  static const int PWM_CLOCK_DIVIDER_4 = 4;

  /// !< 2 = 9.6MHz, fastest you can get
  static const int PWM_CLOCK_DIVIDER_2 = 2;

  /// !< 1 = 4.6875kHz, same as divider 4096
  static const int PWM_CLOCK_DIVIDER_1 = 1;
}

const int HIGH = 1;

const int LOW = 0;
